[["index.html", "How to Be an Rtist: A Beginner’s Guide to Writing Beautiful, Intentional R Code Chapter 1 Preface", " How to Be an Rtist: A Beginner’s Guide to Writing Beautiful, Intentional R Code Adam Sadowski 2022-10-25 Chapter 1 Preface This is a friendly book on how to work with data from start to finish. It is intended to be easy reading for a beginner who is not aware of any R vocabulary, or Information Technology. I’m a Data Analyst. I got my job mostly because of a Master’s in Math and good references (people to speak about his qualities). In the first year of working, I made many mistakes and had many headaches. I constantly Google’d solutions for the problems I faced while working. This allowed me to get my work done but it did not teach me the best way to do my work to avoid future headaches. Mistakes and headaches can be great learning challenges, but in the case of data analysis (and especially for those who use R), it can be demotivating. Mistakes in code cause errors, mistakes in approach cause messy files, and messy files require messy code with more mistakes. Please remember that the R code taught in Statistics courses is almost always not focused on teaching us how to generally handle data; it is only focused on teaching us Statistics. Statistics has a reputation for being hard, especially on those who are learning the subject only because it is required in a not-so-mathematical university program. R has two completely different reputations. Among the students in Statistics courses, it is usually hated. For those who use the tool for work, it is usually loved. Of course, this may due to the fact that students pay to learn R, and workers are paid to learn R. But this is not the only reason for the two different reputations. The workers realize, once they use R day-to-day, that there is an amazing community of other workers who help each other. And not only do they help each other do the work that is currently needed to be done, but they help each other do the work in a smart and beautiful way that is nothing like the work needed in university Statistics courses. Note that the professor teaching university Statistics probably uses R for Statistics. The person learning R outside of university uses R for Data. Data is not Statistics! Statistics is specific to the mathematics used on the data; it is not about work-flow, project-management, and coding to get data and data reports ready. All the things that Statistics is not about, R does beautifully and more. Hence people who pick up R to work and who are not university professors, end up passionate about R and teaching others about R. "],["writing-reports.html", "Chapter 2 Writing Reports 2.1 Lines and Lists 2.2 Code 2.3 Errors 2.4 Links 2.5 Keyboard Shortcuts", " Chapter 2 Writing Reports Data work will involve the preparation of data and data reports. In fact, you may want to report on the preparation of data. Since the code that prepares a report can also prepare the data, you could work in a way that both gets the job done and reports on getting it done. That’s a win-win! Reports are great client-facing examples of your work (and how you work if you report on data preparation). Before employment, they can be presented to potential employers. After employment, they can be presented to your collaborators during data preparation; maybe there will be decisions that need to be made about the data, and the best way to show why decisions are needed will be through a report. For these reasons, this book starts with the fundamentals of writing reports. The files that make reports are called .Rmd files. To start a .Rmd file, open RStudio. In the top menu, click File then New File and finally “R Markdown…”. When you see the pop-up, name the file what you like. Then, in the file, select all (shortcut Cmd-A or Cntrl-A) and hit delete. Knit (i.e. prepare) the document by the shortcut Cmd-Shift-K (or Cntrl-Shift-K). You will see a document that is empty. That is because we have no lines. Let’s get started by writing lines then! 2.1 Lines and Lists On your left in Rstudio (what is called the code source), you have numbers like below that represent lines of text or code: 1 Some text 2 3 4 5 A list in text can be made by first skipping a line, and then starting the next line with numbers followed by a period (.) which is then followed by a space, or by using a hyphen (-) followed by a space: 1 Some text 2 3 1. Start of my list 4 5 Lines 1 to 5 will show in your document as: Some text Start of my list – To create a list within a list, indent twice before using -. Hit tab to indent. 1 Some text 2 3 1. Start of my list 4 - List within my list 5 Lines 1 to 5 will show in your document as: Some text Start of my list List within my list – A list is broken if there is an empty line and a subsequent line that is not indented twice. 1 Some text 2 3 1. Start of my list 4 - List within my list 5 6 This line breaks the list 7 - Some line indented twice in my code source Lines 1 to 7 will show in your document as: Some text Start of my list List within my list This line breaks the list - Some line indented twice in my code source 2.2 Code Code cannot be written on lines like text. For example 1 some_code 2 3 will not work. Code has to be declared in one of two ways. 2.2.1 Declaring With Single Back-Ticks You can insert code into your document using a single back-tick (the ` symbol) before and after: 1 Some text and `some_code` to be processed. 2 `some_more_code` and some more text. 3 `some_lonely_code` R code needs an r after the first back-tick: 1 Some text and `r some_code` to be processed. 2 `r some_more_code` and some more text. 3 `r some_lonely_code` For example, the date can be added to a line of your document using 1 Some text. Did you know today&#39;s date is `r Sys.Date()`? 2 3 Lines 1 to 3 will show in your document as: Some text. Did you know today’s date is 2022-10-25? – 2.2.2 Declaring With Multiple Back-Ticks You can insert multiple lines of code into your document using multiple back-ticks before and after: 10 ```{r} 11 some_code 12 some_more_code 14 ``` The ```{r} starts the R code chunk and the ``` ends the chunk. The primary purpose of a code chunk is to contain multiple lines of code. We will get an error when preparing our document if we try to declare with single back-ticks like here: 10 `r 11 12 Sys.Date() 13 14 Sys.Date() 15 16 ` Instead we must write this as: 10 ```{r} 11 Sys.Date() 12 Sys.Date() 13 ``` The following will be the result of the above chunk in our document: Sys.Date() &gt;&gt; [1] &quot;2022-10-25&quot; Sys.Date() &gt;&gt; [1] &quot;2022-10-25&quot; When declaring code with chunks (multiple back-ticks), the document will show both the code and the result of the code and this can be customized. When declaring code with single back-ticks, the document will show only the result of the code and this cannot be customized. Since the back-ticks take effort to write, there is a shortcut to writing an empty code chunk: command-Shift-I on Mac or ctrl-Shift-I on Windows. 2.2.3 Summary To summarize, compared to declaring code with single back-ticks, Chunks can contain multiple lines. Chunks can show both the code and the result of the code. This is great for showing your work or explaining your code to readers. This flexible property lets you decide whether the chunk shows the code and the result, only one of the two, or neither. 2.3 Errors When code is not written correctly, errors and probably some frustration will follow. R errors are not known for being friendly; they are not kind enough to tell you what is wrong in a way that is easy to understand. When there is an error, you will see it in red text within the Console, which is a box on the bottom left quarter of RStudio (its default layout). The Console is where the code is processed and the result printed. There are symbols we need to know to understand the Console: &gt; means the line of code processed + means a line of code continuing from the last line [1] means the first element of the result of the processed code [n] means the n&#39;th element of the result of the processed code [[1]] [1] means the first element in the first container of the result of the processed code When first learning R, the best way to understand errors is usually not through R’s error message. The best way is by paying close attention to the code and every little detail: misspelling, capitalization, and punctuation. For this reason we want to practice good strategies of writing code. Writing involves naming our own objects and functions. But before that, we should also name our files using a good strategy. For a quick guide on naming files, click here. 2.4 Links To add a clickable link that sends the user to a website, place the website address within inequality symbols &lt; … &gt;. For example: &lt;http://www2.stat.duke.edu/~rcs46/lectures_2015/01-markdown-git/slides/naming-slides/naming-slides.pdf&gt; gives us http://www2.stat.duke.edu/~rcs46/lectures_2015/01-markdown-git/slides/naming-slides/naming-slides.pdf To make this a hyperlink, that is, a shorter, clickable link, write the clickable text (the text you want to the reader to see) in square brackets and the website address in round brackets like so [text-seen-by-reader](link). For example 1 [File Naming Presentation by Jenny Bryan](http://www2.stat.duke.edu/~rcs46/lectures_2015/01-markdown-git/slides/naming-slides/naming-slides.pdf) 2 3 Lines 1 to 3 will show as: File Naming Presentation by Jenny Bryan 2.5 Keyboard Shortcuts Remember, if you are using Windows, use ctrl instead of command alt instead of option Shortcuts: command-Z: Undo (go back) command-shift-Z: Redo (go forward) command-Enter: Process line of code where | is blinking (consistently appearing and disappearing) command-option-C: Process current chunk option-shift-arrow_key: Highlight all to the direction of the arrow …. "],["file-naming.html", "Chapter 3 File Naming 3.1 Consistency 3.2 Why Consistency Matters 3.3 Finding and Organizing Our Files", " Chapter 3 File Naming Now that we have covered how to write lines, we can start writing lines about the data! Actually there is one more small subject to discuss before we do that. In the Preface I said, “Messy files require more messy code which then can lead to more errors.” Let’s do our best to make sure any files we have are not messy. Please note that the below information is useful even if you only have one file of data. At some point, you will have multiple files, and you may want them all organized in the same folder. Data can always be updated, at which time you may have the original file as well as the new file with updated data. Definitions: _ is called underscore. - is called dash. 3.1 Consistency Use _ as a separator, that is, to separate different characteristics of the file. Use - to separate parts within characteristics. For example, lesson-1_on-rmd_2022-02-18.rmd If you have related files that you want to systematically process, then be systematic with the order of characteristics. For example, lesson-1_on-rmd_2022-02-18.rmd lesson-2_on-rmd_2022-02-19.rmd lesson-3_on-rmd_2022-02-20.rmd lesson-1_on-python_2022-02-20.rmd Consider how these files will look when ordered alphabetically in your operating system’s file manager (File Explorer on Window’s or Finder on Mac) if that is important to you. The above files will be ordered like so: lesson-1_on-rmd_2022-02-18.rmd lesson-1_on-ruby_2022-02-20.rmd lesson-2_on-rmd_2022-02-19.rmd lesson-3_on-rmd_2022-02-20.rmd If the order of characteristics start with the most general, then the alphabetic ordering will be more appropriate: on-rmd_lesson-1_2022-02-18.rmd on-rmd_lesson-2_2022-02-19.rmd on-rmd_lesson-3_2022-02-20.rmd on-ruby_lesson-1_2022-02-20.rmd 3.2 Why Consistency Matters Consistency helps you visually process the files you see on your file explorer. It also helps when telling your computer how to process the files. We named the files using separators so that numeric information can be represented. That is, the phrase before the first _ is the first characteristic, the phrase before the second _ is the second characteristic and so on. To process the file names in a way that splits these characteristics, we can use a function str_split from an R package called stringr. File names are strings. Strings are character elements that cannot directly be treated numerically (they need to be converted into numeric elements first for that). To use a function from a package, we first install the package by running install.packages(&quot;stringr&quot;) Delete this line once you are done, as you will have no need to rerun (re-process) it. We use a colon (the symbol :) twice to use a function from a package. If you write stringr:: you will see a drop-down menu of all the functions from stringr. str stands for string. Many function names start with str_. The drop-down menu from writing stringr:: adjusts when you add str_. For every function whose name starts with str_, the general purpose is the processing of strings. Similar to our file names above, the general part of the name comes first, then the _, and then the more specific purpose. There are a few exceptions; some functions in stringr do not start with str_. But most start with str_ because str_ makes it clear what the function will process. This is important as we can avoid the need to write out stringr::. We avoid this by loading the package: making the function names in the package available. To load the package, run the following library(stringr) Now when we only write str_, we still get a drop-down menu. 3.3 Finding and Organizing Our Files To use an str_ function, we need some strings. Let’s get our consistent file names into R. We will use a function called file.choose. This function causes a pop-up that allows you to interactively search your computer files. If you are using Windows, this pop-up may unfortunately pop-up behind RStudio. You will need to Alt-Tab to find the pop-up. Once you see the pop-up, find the folder with your files and double click on (any) one of the files. The function will print the file path (the computer’s representation of where the file exists). Below we assign the file path to the object file_path. file_path &lt;- file.choose() We will now use a function path_dir from the package fs. path_dir will get the path of the directory from the file path. We will assign the result to the object directory_path. library(fs) directory_path &lt;- path_dir(file_path) To get a list of .csv files in this directory, we will use a list.files function. This function has what are called two arguments. The first is the path to the folder that contains our files. The second is the pattern that is unique to the files we want. files &lt;- list.files(directory_path, pattern = &quot;csv&quot;) files &gt;&gt; [1] &quot;gapminder_afganistan_2022-02-21.csv&quot; &gt;&gt; [2] &quot;gapminder_afghanistan_2022-02-21.csv&quot; &gt;&gt; [3] &quot;gapminder_canada_2022-02-21.csv&quot; Now we use str_split which will split our strings. For example, str_split(files, &quot;_&quot;) &gt;&gt; [[1]] &gt;&gt; [1] &quot;gapminder&quot; &quot;afganistan&quot; &quot;2022-02-21.csv&quot; &gt;&gt; &gt;&gt; [[2]] &gt;&gt; [1] &quot;gapminder&quot; &quot;afghanistan&quot; &quot;2022-02-21.csv&quot; &gt;&gt; &gt;&gt; [[3]] &gt;&gt; [1] &quot;gapminder&quot; &quot;canada&quot; &quot;2022-02-21.csv&quot; This result is what is called a list. A list can contain anything. The [[1]] and [[2]] represent the first and second element of the list. The [1] indicates that the element to its very right is the first element. To also separate the file type (.rmd) at the end, preceded by the period, we can adjust our function to separate by _ as well as .. str_split(files, &quot;_.&quot;) &gt;&gt; [[1]] &gt;&gt; [1] &quot;gapminder&quot; &quot;fganistan&quot; &quot;022-02-21.csv&quot; &gt;&gt; &gt;&gt; [[2]] &gt;&gt; [1] &quot;gapminder&quot; &quot;fghanistan&quot; &quot;022-02-21.csv&quot; &gt;&gt; &gt;&gt; [[3]] &gt;&gt; [1] &quot;gapminder&quot; &quot;anada&quot; &quot;022-02-21.csv&quot; What happened? This is not what we want, and it is because . is a special (i.e. meta) character. Special characters mean more to R than the literal symbol itself. The special character . represents any character. Hence we told str_split to use _. as a separator which meant that _A was used as the first separator, and _2 as the second separator. We need to use different special characters to overcome this challenge: [ and ]. These square brackets can be used to surround the distinct characters that str_split will use as separators: [_.] will tell str_split to use either a _ or a literal . as the separator. str_split(files, &quot;[_.]&quot;) &gt;&gt; [[1]] &gt;&gt; [1] &quot;gapminder&quot; &quot;afganistan&quot; &quot;2022-02-21&quot; &quot;csv&quot; &gt;&gt; &gt;&gt; [[2]] &gt;&gt; [1] &quot;gapminder&quot; &quot;afghanistan&quot; &quot;2022-02-21&quot; &gt;&gt; [4] &quot;csv&quot; &gt;&gt; &gt;&gt; [[3]] &gt;&gt; [1] &quot;gapminder&quot; &quot;canada&quot; &quot;2022-02-21&quot; &quot;csv&quot; We can have a cleaner result using str_split_fixed. It is called “fixed” as we can fix the number of splits or pieces. We will split our strings into 4 pieces. str_split_fixed(files, &quot;[_.]&quot;, 4) &gt;&gt; [,1] [,2] [,3] [,4] &gt;&gt; [1,] &quot;gapminder&quot; &quot;afganistan&quot; &quot;2022-02-21&quot; &quot;csv&quot; &gt;&gt; [2,] &quot;gapminder&quot; &quot;afghanistan&quot; &quot;2022-02-21&quot; &quot;csv&quot; &gt;&gt; [3,] &quot;gapminder&quot; &quot;canada&quot; &quot;2022-02-21&quot; &quot;csv&quot; This result is what is called a matrix. Let’s assign it to the object m. m &lt;- str_split_fixed(files, &quot;[_.]&quot;, 4) Now we can see the matrix just by processing m &gt;&gt; [,1] [,2] [,3] [,4] &gt;&gt; [1,] &quot;gapminder&quot; &quot;afganistan&quot; &quot;2022-02-21&quot; &quot;csv&quot; &gt;&gt; [2,] &quot;gapminder&quot; &quot;afghanistan&quot; &quot;2022-02-21&quot; &quot;csv&quot; &gt;&gt; [3,] &quot;gapminder&quot; &quot;canada&quot; &quot;2022-02-21&quot; &quot;csv&quot; Let’s add informative names to the columns of the matrix. To do this, we use a function called colnames. This function will be placed on the left of &lt;- as it is a replacement function. We replace the null (i.e. undefined) column names of our matrix with our list of characteristics. colnames(m) &lt;- c(&quot;source&quot;, &quot;country&quot;, &quot;date&quot;, &quot;file_type&quot;) m &gt;&gt; source country date file_type &gt;&gt; [1,] &quot;gapminder&quot; &quot;afganistan&quot; &quot;2022-02-21&quot; &quot;csv&quot; &gt;&gt; [2,] &quot;gapminder&quot; &quot;afghanistan&quot; &quot;2022-02-21&quot; &quot;csv&quot; &gt;&gt; [3,] &quot;gapminder&quot; &quot;canada&quot; &quot;2022-02-21&quot; &quot;csv&quot; Let’s create an object named df with a function called as_tibble from the package tibble. What is a tibble? It is an R word for table. Remember to install tibble before running library(tibble) df &lt;- as_tibble(m) df &gt;&gt; # A tibble: 3 × 4 &gt;&gt; source country date file_type &gt;&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &gt;&gt; 1 gapminder afganistan 2022-02-21 csv &gt;&gt; 2 gapminder afghanistan 2022-02-21 csv &gt;&gt; 3 gapminder canada 2022-02-21 csv We now need the file path for each of our files. To list the files in our directory, use the function dir_ls. Assign the result to object file_path. file_paths &lt;- dir_ls(directory_path) We will now change our tibble so that there is a new column called file_path that contains our file_paths. To do this, we will use a function from the package dplyr (pronounced “data plier”). The function we will use is named after another word for change: mutate. This function has two arguments. The first is the tibble. The second is the name of the new column, an equal sign, and the values we want in that column. library(dplyr) df &lt;- mutate(df, file_path = file_paths) 3.3.1 Reading in Data We can read in the data related to each file with the help of the file_path column. Not only that, we can read in the data so that it is organized inside our tibble. In each row of our tibble, we will add each file’s data hidden in a little box or “nest”. These nests will go under a column called data. To change our tibble so that there is a new column, we will again use mutate. The first argument is the tibble, just like above. The second is the name of the new column (data), an equal sign, and the values we want in that column. Since the values in this column will be data sets, we need to put these data sets in containers. Where we see \"csv\" 3 times under file_type in our tibble, we will see \"&lt;S3: spec_tbl_df&gt;\" 3 times under data. The &lt; and &gt; mean container. The S3: spec_tbl_df means data frame (another word for data set). We need to use a special function inside mutate when creating our data column so that the values of the data column are containers. This special function is called map from the package purrr. purrr is pronounced like a cat’s purr (the low vibrating sound of happiness) and it refers to purposeful programming with R. The result of map will always be containers. The number of containers will always be the same as the length of the first argument to map. The second argument of map is the function that will be applied to the first argument. To create the data column, the first argument will be the file_path, and the second argument will be a custom read function. The read function below read_csv_c uses a function called read_csv from the package readr. read_csv reads .csv files and determines what kind of columns are in the data (e.g. numeric or character). We will decide the kind of columns ourselves, so we need to prevent the function from doing so. col_types is the argument inside of read_csv with a .default. We need to set the .default to be \"c\". \"c\" stands for character. Character is a safe default as it is the original format of the .csv data. library(readr) read_csv_c &lt;- function(csv_file_path) read_csv(csv_file_path, col_types = c(.default = &quot;c&quot;)) Now we use our new function to read in our data. df &lt;- mutate(df, data = map(file_path, read_csv_c)) df &gt;&gt; # A tibble: 3 × 6 &gt;&gt; source country date file_…¹ file_path data &gt;&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;fs::path&gt; &lt;named list&gt; &gt;&gt; 1 gapmi… afgani… 2022… csv …02-21.csv &lt;spec_tbl_df&gt; &gt;&gt; 2 gapmi… afghan… 2022… csv …02-21.csv &lt;spec_tbl_df&gt; &gt;&gt; 3 gapmi… canada 2022… csv …02-21.csv &lt;spec_tbl_df&gt; &gt;&gt; # … with abbreviated variable name ¹​file_type We no longer need the file_path column so we will select it to be removed by using the select function. df &lt;- select(df, - file_path) "],["opening-the-data.html", "Chapter 4 Opening the Data 4.1 Checking Data 4.2 Finding Functions 4.3 Finding Function Documentation for Understanding Functions", " Chapter 4 Opening the Data We can open our containers or “nests” in data using the function unnest from the package tidyr. library(tidyr) df &lt;- unnest(df, data) df &gt;&gt; # A tibble: 24 × 9 &gt;&gt; source country date file_…¹ conti…² year lifeExp &gt;&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &gt;&gt; 1 gapmind… afghan… 2022… csv Asia 1952 28.801 &gt;&gt; 2 gapmind… afghan… 2022… csv Asia 1957 30.332 &gt;&gt; 3 gapmind… afghan… 2022… csv Asia 1962 31.997 &gt;&gt; 4 gapmind… afghan… 2022… csv Asia 1967 34.02 &gt;&gt; 5 gapmind… afghan… 2022… csv Asia 1972 36.088 &gt;&gt; 6 gapmind… afghan… 2022… csv Asia 1977 38.438 &gt;&gt; 7 gapmind… afghan… 2022… csv Asia 1982 39.854 &gt;&gt; 8 gapmind… afghan… 2022… csv Asia 1987 40.822 &gt;&gt; 9 gapmind… afghan… 2022… csv Asia 1992 41.674 &gt;&gt; 10 gapmind… afghan… 2022… csv Asia 1997 41.763 &gt;&gt; # … with 14 more rows, 2 more variables: pop &lt;chr&gt;, &gt;&gt; # gdpPercap &lt;chr&gt;, and abbreviated variable names &gt;&gt; # ¹​file_type, ²​continent This data looks clean but looks can be deceiving. Remember that we set the df object to be as_tibble? A tibble is not only a table in R, but a cleaner kind of table. It shows only 10 rows, and as many columns that can comfortably be displayed. The sizing of the table surrounds the data, like the header (top line) # A tibble: 24 x 9 tells you how many rows (24) and columns (9) there are. The footer (bottom line) # ... with 14 more rows and 6 more variables tells you what is missing from the display. Even though this data is small (24 rows by 9 columns can be evaluated using our eyes), it is always best to practice techniques that are generalizable to both small and large data. 4.1 Checking Data The simplest way to start evaluating data is to check that the values under each column meet expectations. Since we created the first 4 columns using our file names, we can be sure that these 4 columns are clean. For the next column, continent, we expect values to be continents, capitalized, and spelled correctly. Instead of reading each line with our eyes, we can read each line with our computers. Or a combination of the two. That is exactly how we will start. We will check all unique (i.e. distinct) values under the continent column using distinct. It produces a tibble with only the distinct rows for the column(s) you choose. distinct(df, continent) &gt;&gt; # A tibble: 2 × 1 &gt;&gt; continent &gt;&gt; &lt;chr&gt; &gt;&gt; 1 Asia &gt;&gt; 2 Americas These unique values are perfect. Which means every value is perfect, as these unique values represent them. But what if they were not capitalized, for example? That is in fact the case with our country column: the values are not capitalized because the values came from our file-naming, and it is good practice not to capitalize when file-naming. To capitalize the values in a column, you can use a function called str_to_title. str_to_title(df$country) &gt;&gt; [1] &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; &gt;&gt; [4] &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; &gt;&gt; [7] &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; &gt;&gt; [10] &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; &gt;&gt; [13] &quot;Canada&quot; &quot;Canada&quot; &quot;Canada&quot; &gt;&gt; [16] &quot;Canada&quot; &quot;Canada&quot; &quot;Canada&quot; &gt;&gt; [19] &quot;Canada&quot; &quot;Canada&quot; &quot;Canada&quot; &gt;&gt; [22] &quot;Canada&quot; &quot;Canada&quot; &quot;Canada&quot; df &gt;&gt; # A tibble: 24 × 9 &gt;&gt; source country date file_…¹ conti…² year lifeExp &gt;&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &gt;&gt; 1 gapmind… afghan… 2022… csv Asia 1952 28.801 &gt;&gt; 2 gapmind… afghan… 2022… csv Asia 1957 30.332 &gt;&gt; 3 gapmind… afghan… 2022… csv Asia 1962 31.997 &gt;&gt; 4 gapmind… afghan… 2022… csv Asia 1967 34.02 &gt;&gt; 5 gapmind… afghan… 2022… csv Asia 1972 36.088 &gt;&gt; 6 gapmind… afghan… 2022… csv Asia 1977 38.438 &gt;&gt; 7 gapmind… afghan… 2022… csv Asia 1982 39.854 &gt;&gt; 8 gapmind… afghan… 2022… csv Asia 1987 40.822 &gt;&gt; 9 gapmind… afghan… 2022… csv Asia 1992 41.674 &gt;&gt; 10 gapmind… afghan… 2022… csv Asia 1997 41.763 &gt;&gt; # … with 14 more rows, 2 more variables: pop &lt;chr&gt;, &gt;&gt; # gdpPercap &lt;chr&gt;, and abbreviated variable names &gt;&gt; # ¹​file_type, ²​continent 4.2 Finding Functions How would you know which function to use if I did not tell you? 4.2.1 Google Google is a great search engine that most R programmers use when learning the R language. If we search “r capitalize first letter” we see, on 2022-10-25, the following paragraph as the first result: Convert First letter of every word to Uppercase in R Programming – str_to_title() Function. str_to_title() Function in R Language is used to convert the first letter of every word of a string to Uppercase and the rest of the letters are converted to lower case. The trick is to, within Google, always write r before a question or the desired command, like how to capitalize first letter or simply capitalize first letter. This is a simple example. Most of the time it can be difficult to write in English what you want. This will come with time and practice. At first you may find that the Google search results have nothing to do with what you need. That is a sign to re-word your search, or, if you’ve already re-worded your search, it may be a sign that there is no dedicated function for what you need, or that a different approach is needed. It’s rare that there will be no dedicated function so long as your goal is simple. You may find that it is effective to break down what you’re doing into simple steps, and then search for how to do those steps, as opposed to Googling something long and complicated, involving many steps. 4.2.2 Stack Overflow Speaking of breaking down something complicated so that a search engine like Google can understand it, this is also necessary for others to understand it. For learning R, allowing others to understand your challenge or need is valuable as the R community is not only willing, but also quickly able to help. R users mainly help each other through Stack Overflow. It is a website that easily allows users to ask or answer questions with code, have their code formatted (look nice), and receive feedback. The main draw of Stack Overflow is that the person asking the question has one main responsibility, and that is to produce what is called a minimally reproducible example: an example that can be used (reproduced) by someone else seeing the question, and that does not have unnecessary detail irrelevant to the question (minimal). Describe example EXAMPLE HERE Knowing how to make an example is the majority of the work involved in asking a question on Stack Overflow. 4.2.2.1 Creating Minimally Reproducible Examples If your question involves data frames, you need to learn how to build a data frame before asking your question on Stack Overflow. To build a data frame, you can use the tibble function from package tibble. If you have 2 numeric columns, like in &gt;&gt; # A tibble: 12 × 2 &gt;&gt; year lifeExp &gt;&gt; &lt;chr&gt; &lt;chr&gt; &gt;&gt; 1 1952 28.801 &gt;&gt; 2 1957 30.332 &gt;&gt; 3 1962 31.997 &gt;&gt; 4 1967 34.02 &gt;&gt; 5 1972 36.088 &gt;&gt; 6 1977 38.438 &gt;&gt; 7 1952 68.75 &gt;&gt; 8 1957 69.96 &gt;&gt; 9 1962 71.3 &gt;&gt; 10 1967 72.13 &gt;&gt; 11 1972 72.88 &gt;&gt; 12 1977 74.21 then the first part of your minimal example might look this: tibble(x = c(1, 2, 1, 2), y = c(3, 4, 2, 2)) &gt;&gt; # A tibble: 4 × 2 &gt;&gt; x y &gt;&gt; &lt;dbl&gt; &lt;dbl&gt; &gt;&gt; 1 1 3 &gt;&gt; 2 2 4 &gt;&gt; 3 1 2 &gt;&gt; 4 2 2 And if what you’re trying to achieve is &gt;&gt; Warning in mean.default(lifeExp): argument is not &gt;&gt; numeric or logical: returning NA &gt;&gt; Warning in mean.default(lifeExp): argument is not &gt;&gt; numeric or logical: returning NA &gt;&gt; Warning in mean.default(lifeExp): argument is not &gt;&gt; numeric or logical: returning NA &gt;&gt; Warning in mean.default(lifeExp): argument is not &gt;&gt; numeric or logical: returning NA &gt;&gt; Warning in mean.default(lifeExp): argument is not &gt;&gt; numeric or logical: returning NA &gt;&gt; Warning in mean.default(lifeExp): argument is not &gt;&gt; numeric or logical: returning NA &gt;&gt; # A tibble: 6 × 2 &gt;&gt; year mean_lifeExp &gt;&gt; &lt;chr&gt; &lt;dbl&gt; &gt;&gt; 1 1952 NA &gt;&gt; 2 1957 NA &gt;&gt; 3 1962 NA &gt;&gt; 4 1967 NA &gt;&gt; 5 1972 NA &gt;&gt; 6 1977 NA then the second part of your minimal example might look like this: tibble(x = c(1, 2), mean_y = c(2.5, 2)) &gt;&gt; # A tibble: 2 × 2 &gt;&gt; x mean_y &gt;&gt; &lt;dbl&gt; &lt;dbl&gt; &gt;&gt; 1 1 2.5 &gt;&gt; 2 2 2 To summarize, your entire question on Stack Overflow could look like this: How can I transform the first tibble into the second tibble with a function? library(tibble) tibble(x = c(1, 2, 1, 2), y = c(3, 4, 2, 2)) tibble(x = c(1, 2), mean_y = c(2.5, 2)) To make your question even better, you can format your code by using the reprex function from the reprex package. The curly brackets are needed to tell reprex that you have multiple lines of code. library(reprex) reprex( { library(tibble) tibble(x = c(1, 2, 1, 2), y = c(3, 4, 2, 2)) tibble(x = c(1, 2), mean_y = c(2.5, 2)) } ) &gt;&gt; ℹ Non-interactive session, setting `html_preview = &gt;&gt; FALSE`. &gt;&gt; ℹ Rendering reprex... &gt;&gt; ✔ Reprex output is on the clipboard. Finally your question looks friendly: How can I transform the first tibble into the second tibble with a function? library(tibble) tibble(x = c(1, 2, 1, 2), y = c(3, 4, 2, 2)) #&gt; # A tibble: 4 × 2 #&gt; x y #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 3 #&gt; 2 2 4 #&gt; 3 1 2 #&gt; 4 2 2 tibble(x = c(1, 2), mean_y = c(2.5, 2)) #&gt; # A tibble: 2 × 2 #&gt; x mean_y #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 2.5 #&gt; 2 2 2 4.3 Finding Function Documentation for Understanding Functions Once you’ve found a function (or usually, a set of functions) recommended to you by Google’s search results, or by R users on Stack Overflow, it would be wise to understand how the function(s) work; specifically, the inputs and outputs. Both Google and Stack Overflow can be overwhelming. Google gives a variety of websites. Which do you choose? A question on Stack Overflow can receive multiple answers, with each using different approaches and functions. Again, which do you choose? Let’s start with Google then. 4.3.1 Google Remember, after searching “r capitalize first letter” we saw the following paragraph as the first result: Convert First letter of every word to Uppercase in R Programming – str_to_title() Function. str_to_title() Function in R Language is used to convert the first letter of every word of a string to Uppercase and the rest of the letters are converted to lower case. This paragraph is from a website called GeeksforGeeks I would not recommend to use this website. That is, after searching “r capitalize first letter” and seeing the the above paragraph, I would not recommend to visit the website to understand the function. And for multiple reasons. You are not familiar with the format of the website. You will find yourself on multiple websites when you need to discover and learn about multiple functions. You will then have to navigate the formats of these websites. Many things can get in the way of reading the instructions, like pop-ups to sign up for the website’s email list, advertisements for completely unrelated products (everything you need to learn R is FREE), and recommended articles to distract you. It is more effective to use a single, standardized resource when learning about functions. Thankfully, R has a few. After reading the above paragraph and learning that the function we need may be str_to_title(), we can now Google search “r str_to_title” instead of “r capitalize first letter”. Again, Google shows multiple websites, but we are looking for one that is standardized. tidyverse.org is one of those websites, so we click the result that has “tidyverse.org” in the website address This brings us to this page: https://stringr.tidyverse.org/reference/case.html As standard, there are multiple sections to the webpage describing a function: Usage, Arguments and Examples. Usage shows the format of the inputs to the function. Any input with an = beside it has a default value. A default value usually indicates that most users will not need to change the value. The Usage str_to_title(string, locale = \"en\") tells us that string should be an object containing some string(s) or a string itself. It has no default value; we must provide one. locale has the default value \"en\". The Arguments tell us more about the inputs in case the Usage is not enough. When first learning R, Arguments can be overwhelming; you might quickly find yourself not understanding the words contained therein, and having to continuously look up definitions (or more function documentation) in order to understand. 4.3.2 Stack Overflow Another way of understanding functions is to be presented with answers from others on Stack Overflow. These answers don’t need to be answers to the questions you have posted on Stack Overflow; they can be answers to questions posted by others. For example, here is a question dated from 2019: https://stackoverflow.com/questions/58996293/transforming-a-dataframe-by-multiplying-a-columns-elements-by-the-names-of-th There are three separate answers that have up votes (positive feedback represented by the digit on the top left of an answer): 1 using the data.table package; 1 using base R (R without packages); and 1 using tidyr. Notice how the answer using tidyr is far more simple; it is one line of code. This word tidy keeps popping up, and for good reason: the functions in this package and more broadly in the tidyverse (the tidy universe) are designed to make coding short and simple. It is possible to add comments to the answers on Stack Overflow, with further questions about the functions if there is something you don’t understand. Fortunately the tidyverse functions are well documented because of their standardized webpages, and because of multiple, free books on using them for specific tasks. 4.3.3 Books There are many books describing tidyverse functions. Finding a good book is a strong alternative to using Google or Stack Overflow toward understanding functions. A book can hold your hand throughout each step and provide a narrative. It can also be designed toward a specific task, just as this one is designed toward getting you started as quickly and comfortably as possible. "],["understanding-tidyverse-functions.html", "Chapter 5 Understanding Tidyverse Functions 5.1 mutate 5.2 Pumping with %&gt;% 5.3 Grouping with group", " Chapter 5 Understanding Tidyverse Functions So far we used mutate from dplyr, unnest from tidyr, read_csv from readr, map from purrr, as_tibble from tibble, and str_to_title from stringr. Since we are using so many tidyverse packages, we may as well load the tidyverse if possible. Fortunately it is possible by running library(tidyverse). After doing so, all tidyverse functions are now available to us. 5.1 mutate We already went over mutate. This function is used to both create new columns and overwrite existing columns. We can overwrite an existing column like so: df &lt;- mutate(df, year = as.numeric(year)) Having a numeric year is useful if, for example, we want to filter the data by years between 1960 and 1980. This is done with filter. df &lt;- filter(df, 1960 &lt; year &amp; year &lt; 1980) 5.2 Pumping with %&gt;% Notice that the examples in the function documentation for mutate (https://dplyr.tidyverse.org/reference/mutate.html) and filter use the symbol %&gt;%. The %&gt;% is very simple. It simply sends the left side to the right side. The other property to remember is that %&gt;% holds mathematical priority before brackets and exponents. So if you know BEDMASS, then you also know BE%&gt;%DMASS. sqrt(5) &gt;&gt; [1] 2.236068 is the same as 5 %&gt;% sqrt &gt;&gt; [1] 2.236068 But 5 * 5 %&gt;% sqrt &gt;&gt; [1] 11.18034 is not the same as (5 * 5) %&gt;% sqrt &gt;&gt; [1] 5 For a more relevant example, df &lt;- mutate(df, year = as.numeric(year)) is the same as df &lt;- df %&gt;% mutate(year = as.numeric(year)) which is the same as df &lt;- df %&gt;% mutate(year = year %&gt;% as.numeric) 5.3 Grouping with group Notice that the examples in the function documentation for filter (https://dplyr.tidyverse.org/reference/filter.html) use the function group_by. group_by groups the data for the function(s) that follow group_by. Let us create a simple example to demonstrate… (To be continued) "],["strings.html", "Chapter 6 Strings 6.1 Patterns and Regular Expressions (regexes) 6.2 Motivation 6.3 Understanding Representations", " Chapter 6 Strings 6.1 Patterns and Regular Expressions (regexes) Short for regular expressions, regex (pronounced reg-ex) is a language for describing patterns in strings. Like any language, regex will appear foreign and difficult to understand without constantly looking up definitions for symbols. A good dictionary is the regex cheat sheet; search for “Regular Expressions” in https://www.rstudio.com/resources/cheatsheets/. The important definitions are in the left and bottom boxes. Why learn this language? When do you need a language for describing patterns in strings? 6.2 Motivation The first definition under heading “Character Classes” is [[:digit:]] or \\\\d Digits; [0-9] This tells us that to represent digits in patterns, we can write \"[[:digit:]]\" or \"\\\\d\". When do we need patterns? Let’s say we want to make sure each row in the date column of our df has exactly 8 digits: 4 for the year, 2 for the month and 2 for the day. We cannot write the 8 digits directly, we need to represent them abstractly; that is the responsibility of patterns. The pattern for digits is \"[[:digit:]]\" or \"\\\\d\". Now we need a pattern for “8 times”. We also cannot simply write 8, as we want to avoid representing the character 8. We now look for the abstract pattern representing “times”: or, in other words, “occurences”. On the bottom right, this pattern will be under the grey heading “Quantifiers”. The 4th defintion is {n} Matches exactly n times This tells us that to match 8 times, we can write \"{8}\". Combining what we learned about digits, we now write a pattern for digits 8 times: \"\\\\d{8}\". Before using this pattern, let us try to understand each symbol. The \\\\ are needed to make sure that the pattern is not for the character “d” itself. Similarly, the { and } are needed to make sure that the pattern is not for the number “8” itself. If we try to use our pattern to filter for dates with 8 digits, we get the following df %&gt;% filter(date %&gt;% str_detect(&quot;\\\\d{8}&quot;)) &gt;&gt; # A tibble: 0 × 5 &gt;&gt; # … with 5 variables: source &lt;chr&gt;, country &lt;chr&gt;, &gt;&gt; # date &lt;chr&gt;, file_type &lt;chr&gt;, data &lt;named list&gt; 0 rows in our date column have digits exactly 8 times. How can that be? Looking back at our date column, what do we see? df &gt;&gt; # A tibble: 3 × 5 &gt;&gt; source country date file_…¹ data &gt;&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;named list&gt; &gt;&gt; 1 gapminder afganistan 2022-02-… csv &lt;spec_tbl_df&gt; &gt;&gt; 2 gapminder afghanistan 2022-02-… csv &lt;spec_tbl_df&gt; &gt;&gt; 3 gapminder canada 2022-02-… csv &lt;spec_tbl_df&gt; &gt;&gt; # … with abbreviated variable name ¹​file_type date has 4 digits, followed by a hyphen, followed by 2 digits, followed by a hyphen, followed by 2 digits. Our pattern simply represents 8 digits, one after the other with nothing in between. If we alter our pattern to \"\\\\d{4}-\\\\d{2}-\\\\d{2}\", we get the expected result: df %&gt;% filter(date %&gt;% str_detect(&quot;\\\\d{4}-\\\\d{2}-\\\\d{2}&quot;)) &gt;&gt; # A tibble: 3 × 5 &gt;&gt; source country date file_…¹ data &gt;&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;named list&gt; &gt;&gt; 1 gapminder afganistan 2022-02-… csv &lt;spec_tbl_df&gt; &gt;&gt; 2 gapminder afghanistan 2022-02-… csv &lt;spec_tbl_df&gt; &gt;&gt; 3 gapminder canada 2022-02-… csv &lt;spec_tbl_df&gt; &gt;&gt; # … with abbreviated variable name ¹​file_type Now we not only checked that each row in date has 8 digits, but that theses digits are separated by hyphens in a XXXX-XX-XX format. We still have not confirmed that the date column is in YYYY-MM-DD format (year-month-day format). This is unfortunately impossible for some cases. We cannot determine whether 02-04 is February 4nd or April 2nd unless we know whether the date was entered as MM-DD or DD-MM. Fortunately we can check cases where the day is greater than the 12th. We do so by checking whether the month in YYYY-MM-DD is between 01 and 12. To do so we will adjust our pattern slightly so that month becomes a reference. To make a reference in a pattern, we surround the part we want to reference with round brackets: ( and ). pattern &lt;- &quot;\\\\d{4}-(\\\\d{2})-\\\\d{2}&quot; To extract the reference, we must refer to it by number. We need to use a number, as it is possible to have more than one reference group. Again we use \\\\ to make sure the pattern is not for the number “1” itself. replacement &lt;- &quot;\\\\1&quot; We now use our pattern and replacement in the function str_replace: month &lt;- &quot;2022-13-01&quot; %&gt;% str_replace(pattern, replacement) month &gt;&gt; [1] &quot;13&quot; We can treat this as numeric. month %&gt;% as.numeric &gt;&gt; [1] 13 And then check whether it is above 12. month %&gt;% as.numeric &gt; 12 &gt;&gt; [1] TRUE To do this for every row of our data frame, we will create a month column, treat it as numeric, and filter by values greater than 12: df &lt;- df %&gt;% mutate(month = date %&gt;% str_replace(&quot;\\\\d{4}-(\\\\d{2})-\\\\d{2}&quot;, &quot;\\\\1&quot;) %&gt;% as.numeric) df %&gt;% filter(month &gt; 12) &gt;&gt; # A tibble: 0 × 6 &gt;&gt; # … with 6 variables: source &lt;chr&gt;, country &lt;chr&gt;, &gt;&gt; # date &lt;chr&gt;, file_type &lt;chr&gt;, data &lt;named list&gt;, &gt;&gt; # month &lt;dbl&gt; There are no rows where month is greater than 12. Notice how the mutate is on a separate line after the pump %&gt;%. This is so that the mutate can fit on one line as opposed to the less easily readable version below. df &lt;- df %&gt;% mutate(month = date %&gt;% str_replace(&quot;\\\\d{4}-(\\\\d{2})-\\\\d{2}&quot;, &quot;\\\\1&quot;) %&gt;% as.numeric) 6.3 Understanding Representations If data contains characters like quotes and backslashes, R cannot directly represent them in a string. We can try to write each of these directly in a string and see what happens. Quotes: &quot;&quot;&quot; &gt;&gt; Error: &lt;text&gt;:1:3: unexpected INCOMPLETE_STRING &gt;&gt; 1: &quot;&quot;&quot; &gt;&gt; ^ R reads the first two set of quotes \"\" as an empty string, and considers the third set to be starting a second, incomplete string. Backslash: &quot;\\&quot; &gt;&gt; Error: &lt;text&gt;:1:1: unexpected INCOMPLETE_STRING &gt;&gt; 1: &quot;\\&quot; &gt;&gt; ^ The backslash has a special behaviour, preventing the second \" from ending the string. Solution: Since R cannot represent quotes and backslash directly, it must instead represent them indirectly with special sequences of characters. For quotes, the representative sequence in R is \\\". For a backslash, the sequence is \\\\. When we place these sequences in strings, the output is not an error. &quot;\\&quot;&quot; &gt;&gt; [1] &quot;\\&quot;&quot; &quot;\\\\&quot; &gt;&gt; [1] &quot;\\\\&quot; Further, we can see what each sequence represents by using the function writeLines: &quot;\\&quot;&quot; %&gt;% writeLines &gt;&gt; &quot; &quot;\\\\&quot; %&gt;% writeLines &gt;&gt; \\ Sequences \\\" and \\\\ start with a backslash because a backslash has a specific behaviour: it prevents the normal interpretation of the next character. The backslash in the string\"\\\"\" prevents the second quotes from being interpreted as the end of the string. As for the string \"\\\\\", because of the first backslash the second backslash is not normally interpreted as “preventing the normal interpretation of the next character”. Yes you will likely have to re-read that. \\\" and \\\\ are called special characters. Special characters are called special because they hold a special property: they each represent one thing (a unique character that cannot be represented directly). \\\" represents quotes, and \\\\ represents backslash. Scan the following list of special characters and what they represent. Special Characters Represents \\n newline \\r carriage return \\t tab \\b backspace \\a alert (bell) \\f form feed \\v vertical tab \\\\ backslash \\ \\’ ASCII apostrophe ’ \\” ASCII quotation mark ” \\` ASCII grave accent (backtick) ` Notice how each has one backslash except for the case of \\\\. Again these special characters represent one thing. Representations of multiple things, however, have multiple backslashes (two to be exact). As an example, \\\\d represents multiple things because it represents any of the multiple digits from 0 to 9. \\\\ is a strange case. It is the only special character representing one thing with multiple backslashes. It is an even stranger case when used inside a pattern. We get an error: pattern &lt;- &quot;\\\\&quot; &quot;\\\\&quot; %&gt;% str_detect(&quot;\\\\&quot;) &gt;&gt; Error in stri_detect_regex(string, pattern, negate = negate, opts_regex = opts(pattern)): Unrecognized backslash escape sequence in pattern. (U_REGEX_BAD_ESCAPE_SEQUENCE, context=`\\`) An error does not happen with any of the other special characters used in this way. The reason is that \\\\ is already used in patterns like \\\\d. If the pattern to match the string \"\\\\\" was simply \"\\\\\", representations like \\\\d would lose their meaning. For example, instead of matching digits, \\\\d would just match \\\\ followed by a d. To match the string \"\\\\\" we must use the pattern \"\\\\\\\\\". To remember this, consider how R views four backslashes: &quot;\\\\\\\\&quot; %&gt;% writeLines &gt;&gt; \\\\ "],["avoiding-repetition.html", "Chapter 7 Avoiding Repetition", " Chapter 7 Avoiding Repetition Let’s say we need to read data in again, and we have named your files as per the chapter on File Naming. To summarize, the file names have phrases with words separated by -, and multiple phrases are separated by _. Instead of copy-pasting the same code we used the previous time, we can avoid this repetition with a function. We can create this function by assigning function() to an object, and entering the inputs inside the () like so: sum &lt;- function(x, y) x + y sum(2, 2) &gt;&gt; [1] 4 The inputs of a function should be the parts of the function that change over repeated use. Since we want to repeat the code to read in data, but without being repetitive, our function will only contain inputs that are not repetitive. What part of reading our data is not repetitive now that we want to repeat the task for a set of different files. For one, we can imagine that a new set of files might have a different number of phrases in the file names. So one input of our function can be n_phrases. Two, we can imagine that the phrases represent something different. Since we named them previously, let us call a second input of our function names_phrases. Lastly, we need to name our function. The function name should reflect the main behaviour. If it is hard to identify the main behaviour, then it is probably best to split the function into multiple functions. Naming the functions appropriately is important for readability. Let us start by listing the behaviours of our function or functions: Choose a file Find the folder (directory) of this file Find the names of the csv files in this folder Get a matrix from splitting the phrases in each name Name the columns and turn the matrix into a tibble For each row representing a file, read its respective data into the tibble That is a lot for one name to represent. Hence it is more prudent to separate these behaviours into multiple functions. CONTINUE HERE Although we could place all the code needed to read in data inside our function and name the function read_csv_in_df, this is not a good idea. First, it is inconsistent with the popular function read_csv, which has more than two arguments, the first of which is a file path. With only two arguments, our function has the form function(n_phrases, names_phrases){code}. The code it will execute is in curly brackets {}. Although curly brackets were not needed in function(x, y) x + y, it will be needed here as the code will have multiple lines. Although we could place all the code needed to read in data inside and name the function read_csv_in_df, then we would be acting without much care. read_csv_in_df &lt;- function(n_phrases, names_phrases){ one_file_path &lt;- file.choose() directory_path &lt;- one_file_path %&gt;% path_dir file_names &lt;- directory_path %&gt;% list.files(pattern = &quot;csv&quot;) file_paths &lt;- directory_path %&gt;% dir_ls split_matrix &lt;- file_names %&gt;% str_split_fixed(&quot;[._]&quot;, n_phrases) colnames(split_matrix) &lt;- names_phrases df &lt;- split_matrix %&gt;% as_tibble %&gt;% mutate(data = map(file_paths, read_csv)) df } # read_csv_in_df # read_csv_in_df(4, c(&quot;source&quot;, &quot;country&quot;, &quot;date&quot; ,&quot;file_type&quot;)) "],["next-steps-for-this-guide.html", "Chapter 8 Next Steps for This Guide", " Chapter 8 Next Steps for This Guide How to make your work reproducible using “R projects” How to mask or randomize data in order ot make it public How to build your own website How to build tables (gt) and plots (ggplot) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
